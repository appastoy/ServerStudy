using System.Collections.Generic;
using FluentAssertions;
using Neti.CodeCompilation;
using Neti.CodeGeneration.Builders;
using NUnit.Framework;

namespace Neti.CodeGeneration.Tests
{
	class MessageGroupCodeBuilderTests
	{
		[Test]
		public void GenerateMessageGroupCodeTest()
		{
			var expectingCodeMap = new Dictionary<string, string>
			{
{ "ServerToClient.MessageId.g.cs", 
$@"{CodeConstants.AutoGeneratedHeader}

// No using

namespace Neti.CodeGeneration.Tests.Schema
{{
	public static partial class ServerToClient
	{{
		public static class MessageId
		{{
			public const ushort Response1 = 200;
			public const ushort Response2 = 201;
		}}
	}}
}}" },

{ "ClientToServer.MessageId.g.cs",
$@"{CodeConstants.AutoGeneratedHeader}

// No using

namespace Neti.CodeGeneration.Tests.Schema
{{
	public static partial class ClientToServer
	{{
		public static class MessageId
		{{
			public const ushort Request1 = 100;
			public const ushort Request2 = 101;
		}}
	}}
}}" },

{ "ServerToClient.Rpc.g.cs",
$@"{CodeConstants.AutoGeneratedHeader}

// No using

namespace Neti.CodeGeneration.Tests.Schema
{{
	public static partial class ServerToClient
	{{
		public static class Rpc
		{{
			public void Response1(TcpSession sender, uint uintParam)
			{{
				using (var writer = sender.CreatePacketWriter())
				{{
					writer.Write(MessageId.Response1);
					writer.Write(uintParam);
				}}
			}}

			public void Response2(TcpSession sender, bool boolParam, decimal decimalParam)
			{{
				using (var writer = sender.CreatePacketWriter())
				{{
					writer.Write(MessageId.Response2);
					writer.Write(boolParam);
					writer.Write(decimalParam);
				}}
			}}
		}}
	}}
}}" },

{ "ClientToServer.Rpc.g.cs",
$@"{CodeConstants.AutoGeneratedHeader}

// No using

namespace Neti.CodeGeneration.Tests.Schema
{{
	public static partial class ClientToServer
	{{
		public static class Rpc
		{{
			public void Request1(TcpClient sender, int intParam)
			{{
				using (var writer = sender.CreatePacketWriter())
				{{
					writer.Write(MessageId.Request1);
					writer.Write(intParam);
				}}
			}}

			public void Request2(TcpClient sender, string stringParam, float floatParam)
			{{
				using (var writer = sender.CreatePacketWriter())
				{{
					writer.Write(MessageId.Request2);
					writer.Write(stringParam);
					writer.Write(floatParam);
				}}
			}}
		}}
	}}
}}" },

{ "ClientToServer.MessageHandling.g.cs",
$@"{CodeConstants.AutoGeneratedHeader}

// No using

namespace Neti.CodeGeneration.Tests.Schema
{{
	public static partial class ClientToServer
	{{
		public static class MessageHandling
		{{
			public delegate void Request1Handler(TcpSession sender, int intParam);
			public delegate void Request2Handler(TcpSession sender, string stringParam, float floatParam);

			Request1Handler onRequest1;
			Request2Handler onRequest2;

			public event Request1Handler OnRequest1 {{ add {{ onRequest1 += value; }} remove {{ onRequest1 -= value; }} }}
			public event Request2Handler OnRequest2 {{ add {{ onRequest2 += value; }} remove {{ onRequest2 -= value; }} }}

			public void Handle(TcpSession sender, PacketReader reader)
			{{
				try
				{{
					reader.Reset();

					var messageId = reader.Read<ushort>();
					switch (messageId)
					{{
						case MessageId.Request1: HandleRequest1(sender, reader); break;
						case MessageId.Request2: HandleRequest2(sender, reader); break;

						default: throw new UnknownMessageException(messageId);
					}}
				}}
				finally
				{{
					reader.Use();
				}}
			}}

			void HandleRequest1(TcpSession sender, PacketReader reader)
			{{
				var intParam = reader.Read<int>();

				Handle_Request1(sender, intParam);
				onRequest1?.Invoke(sender, intParam);
			}}

			void HandleRequest2(TcpSession sender, PacketReader reader)
			{{
				var stringParam = reader.ReadString();
				var floatParam = reader.Read<float>();

				Handle_Request2(sender, stringParam, floatParam);
				onRequest2?.Invoke(sender, stringParam, floatParam);
			}}

			protected abstract void Handle_Request1(TcpSession sender, int intParam);
			protected abstract void Handle_Request2(TcpSession sender, string stringParam, float floatParam);
		}}
	}}
}}" },

{ "ServerToClient.MessageHandling.g.cs",
$@"{CodeConstants.AutoGeneratedHeader}

// No using

namespace Neti.CodeGeneration.Tests.Schema
{{
	public static partial class ServerToClient
	{{
		public static class MessageHandling
		{{
			public delegate void Response1Handler(TcpClient sender, uint uintParam);
			public delegate void Response2Handler(TcpClient sender, bool boolParam, decimal decimalParam);

			Response1Handler onResponse1;
			Response2Handler onResponse2;

			public event Response1Handler OnResponse1 {{ add {{ onResponse1 += value; }} remove {{ onResponse1 -= value; }} }}
			public event Response2Handler OnResponse2 {{ add {{ onResponse2 += value; }} remove {{ onResponse2 -= value; }} }}

			public void Handle(TcpClient sender, PacketReader reader)
			{{
				try
				{{
					reader.Reset();

					var messageId = reader.Read<ushort>();
					switch (messageId)
					{{
						case MessageId.Response1: HandleResponse1(sender, reader); break;
						case MessageId.Response2: HandleResponse2(sender, reader); break;

						default: throw new UnknownMessageException(messageId);
					}}
				}}
				finally
				{{
					reader.Use();
				}}
			}}

			void HandleResponse1(TcpClient sender, PacketReader reader)
			{{
				var uintParam = reader.Read<uint>();

				Handle_Response1(sender, uintParam);
				onResponse1?.Invoke(sender, uintParam);
			}}

			void HandleResponse2(TcpClient sender, PacketReader reader)
			{{
				var boolParam = reader.Read<bool>();
				var decimalParam = reader.Read<decimal>();

				Handle_Response2(sender, boolParam, decimalParam);
				onResponse2?.Invoke(sender, boolParam, decimalParam);
			}}

			protected abstract void Handle_Response1(TcpClient sender, uint uintParam);
			protected abstract void Handle_Response2(TcpClient sender, bool boolParam, decimal decimalParam);
		}}
	}}
}}" }
			};

			var compiler = new CSharpCompiler();
			var result = compiler.CompileFromDirectory("..\\..\\..\\Schema", 
													   assemblyName: "Scheme.dll",
													   references: new[] { typeof(TcpSession).Assembly });
			result.Success.Should().BeTrue();

			var builder = new MessageGroupCodeBuilder();
			var generationContexts = builder.BuildContexts(result.Assembly);
			var codeResults = CodeGenerationPipeline.Generate(generationContexts);
			foreach (var codeResult in codeResults)
			{
				expectingCodeMap[codeResult.LocalPath].Should().Be(codeResult.Code);
			}
		}
	}
}
